/**
 * @brief Procedimiento principal para el problema productor-consumidor.
 * 
 * Este procedimiento inicializa los hilos de productores y consumidores, configura
 * los recursos compartidos como la cola y las primitivas de sincronización, y
 * gestiona la creación, ejecución y finalización de los hilos.
 * 
 * @param argc Número de argumentos pasados al programa (se espera que sean 8).
 * @param argv[] Arreglo de argumentos que define el número de unidades, el número de
 *               productores/consumidores, y los rangos de retrasos para ambos.
 */
procedure main(argc, argv[]):
  if argc = 8 then
  /**
  * @brief Variable compartida que define el número total de unidades a producir.
  */
    shared unit_count := integer(argv[1])
  /**
  * @brief Número de hilos productores que se deben crear.
  */
    shared producer_count := integer(argv[2])
  /**
  * @brief Número de hilos consumidores que se deben crear.
  */
    shared consumer_count := integer(argv[3])
  /**
  * @brief Retraso mínimo entre las producciones.
  */
    shared producer_min_delay := integer(argv[4])
  /**
  * @brief Retraso máximo entre las producciones.
  */
    shared producer_max_delay := integer(argv[5])
  /**
  * @brief Retraso mínimo entre las consumiciones.
  */
    shared consumer_min_delay := integer(argv[6])
  /**
  * @brief Retraso máximo entre las consumiciones.
  */
    shared consumer_max_delay := integer(argv[7])
  /**
  * @brief Cola compartida donde los productores colocan unidades y los consumidores las toman.
  */

    shared queue := create_integer_queue()
  /**
  * @brief Mutex para controlar el acceso a la cola.
  */
    shared can_access_queue := create_mutex()
  /**
  * @brief Contador de la siguiente unidad a producir.
  */
    shared next_unit := 0
    shared can_access_next_unit := create_mutex()

    declare producers := create_threads(producer_count, produce1)
    declare consumers := create_threads(consumer_count, consume3)

    shared can_consume := create_semaphore(0)

    join_threads(producers)

    for index := 0 to consumer_count do
      lock(can_access_queue)
        enqueue(queue, -1)
      unlock(can_access_queue)
      signal(can_consume)
    end for

    join_threads(consumers)
  end if
end procedure

procedure produce1:
  while true do
    declare my_unit := 0
    lock(can_access_next_unit)
      if next_unit < unit_count then
        next_unit := next_unit + 1
        my_unit := next_unit
      else
        unlock(can_access_next_unit)
        break while
      end if
    unlock(can_access_next_unit)
  
    delay(random_between(producer_min_delay, producer_max_delay))
    lock(can_access_queue)
      enqueue(queue, my_unit)
    unlock(can_access_queue)
    print("Produced ", my_unit)
    signal(can_consume)
  end while
end procedure

procedure consume3:
  while true do
    wait(can_consume)
    lock(can_access_queue)
    declare my_unit := dequeue(queue)
    unlock(can_access_queue)
    if my_unit = -1 then
      break while
    else
      print("\tConsuming ", my_unit)
      delay(random_between(consumer_min_delay, consumer_max_delay))
    end if
  end while
end procedure

function random_between(min, max):
  return min + rand() % (max - min)
end function